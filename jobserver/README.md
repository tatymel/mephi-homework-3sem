# JobServer

Напишите программу, которая будучи запущенной в директории обойдёт текущую директорию и все поддиректории рекурсивно и запустит все исполняемые файлы которые там найдёт.

Программа должны принимать один аргумент - число задающее максимальную параллельность, с которой нужно выполнять пользовательские команды.

## Пример: make -j

В очень упрощённой модели, `make` принимает от пользователя набор команд и выполняет эти команды по одной.

Выполнять команды по одной - это не самая лучшая стратегия. В любом современном процессоре есть есть несколько ядер, было бы логично запускать одновременно не больше `k` команд. Ровно эту функцию выполняет флаг `-j`. `make -j 4` гарантирует, что одновременно будет запущенно не более 4-х пользовательских команд.

Интересная ситуация возникает, когда одной из пользовательских команд является `make`. То есть, когда `make` вызывается рекурсивно.

  * В этой ситуации не хочется считать процесс `make`-а как пользовательский. Он не потребляет ресурсов сам по себе, а значит дополнительные процессы `make`-а не должны замедлять работу.

  * Хочется, чтобы `-j4` ограничивал параллельность глобально на все рекурсивные вызовы, а не локально только внутри одного процесса `make`.

  * Если учитывать рекурсивные вызовы `make` в лимите на параллельность, то в какой-то момент весь лимит будет занят только процессами `make`-а и система придёт в зависшие состояние.

Возникает интересная задача координации между многими процессами. В этой задаче требуется реализовать следующий алгоритм:

```
Cоздать семафор с начальным значением k.

make:
  Запустить все рекурсивные процессы make.
  В цикле, пока остались не запущенные пользовательские процессы.
    Опустить семафор.
    Запустить процесс watcher.
  Дождаться завершения всех дочерних процессов.

watcher:
  Запустить пользовательский процесс.
  Дождаться завершения пользовательского процесса.
  Поднять семафор.
```

Можно убедиться, что подобный алгоритм удовлетворяет всем выше перечисленным требованиям. Остаётся только один вопрос - как реализовать семафор?

Оказывается, для этой задачи подходит обычный unix pipe. В операции `acquire()` будем писать 1 байт в пайп, в операции `release()` будем читать один байт из пайпа. Значением семафора будет равно количеству байт во внутреннем буфере.

## Советы

  * Полезные функции:
    * opendir, readdir, closedir
    * fork, exec
    * pipe

  * Для упрощения дебага, полезно обрабатывать все ошибки системных вызовов. Для этого удобно использовать функцию `err`

```c
DIR* d = opendir(".");
if (d == NULL) {
    err(1, "opendir");
}
```

  * Чтобы запустить тесты по одному, можно воспользоваться следующей командой

```
make compile && (set -ex; cd pstree_test; env TMP=$(mktemp -d) ../main)
```

## Полезные ссылки

  * http://make.mad-scientist.net/papers/jobserver-implementation/
